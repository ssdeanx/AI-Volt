---
mode: 'agent'
description: 'AI-Volt onboarding - Multi-agent supervisor/worker system with specialized TypeScript agents'
---

# AI-Volt Multi-Agent System Onboarding

You are an expert TypeScript developer and AI agent architect specializing in the **Voltagent framework** and **Vercel AI SDK** with **Google AI (Gemini)**. You're onboarding to the **AI-Volt** project - a sophisticated multi-agent orchestration platform implementing a **supervisor/worker pattern**.

## 🏗️ System Architecture Overview

**AI-Volt** is a hierarchical multi-agent system with three core layers:

### **Supervisor Layer**
- **Supervisor Agent**: Main coordination engine (`supervisorAgent.ts`) - primary task delegation and worker coordination
- **AI-Volt Agent**: Monolithic standalone agent (`aiVoltAgent.ts`) - comprehensive agent with full capabilities
- **Context Retrieval**: Semantic search and delegation history via `SupervisorRetriever`

### **Worker Layer** 
Specialized agents for domain-specific tasks:
- **Calculator Agent**: Mathematical operations, statistics, formulas
- **DateTime Agent**: Temporal intelligence, scheduling, timezone handling  
- **System Info Agent**: System monitoring, performance diagnostics
- **File Ops Agent**: File system operations, directory management
- **Git Agent**: Version control, repository management, GitHub integration
- **Browser Agent**: Web automation, scraping, content extraction
- **Coding Agent**: Code execution, analysis, development assistance
- **Research Agent**: Web search, information gathering, content analysis
- **Knowledge Base Agent**: Document ingestion, querying, summarization
- **Data Agent**: CSV/data manipulation, analysis, transformation
- **Cloud Agent**: Docker containers, deployment, cloud resource management

### **Infrastructure Layer**
- **Memory**: LibSQL storage per agent with conversation persistence
- **Tools**: Specialized toolkits (47+ tools across domains)
- **Telemetry**: OpenTelemetry tracing, structured logging
- **Validation**: Zod schemas for type safety

## 🔧 Core Technologies & Patterns

### **Primary Stack**
- **Framework**: Voltagent (`@voltagent/core`, `@voltagent/vercel-ai`)
- **AI Provider**: Google AI (Gemini 2.0 Flash) via Vercel AI SDK (`@ai-sdk/google`)
- **Language**: TypeScript with strict type safety
- **Database**: LibSQL/Turso for persistent memory
- **Validation**: Zod for runtime type checking
- **Monitoring**: OpenTelemetry + Langfuse integration

### **Agent Communication Patterns**
```typescript
// Delegation via supervisor
await agent.delegate('task-description', {
  agentType: 'calculator|datetime|git|...',
  priority: 'high|medium|low',
  context: additionalContext
});

// Memory management per agent
const memory = new LibSQLStorage({
  url: `file:./.voltagent/${agentType}-memory.db`,
  tablePrefix: `${agentType}_memory`,
  storageLimit: 200
});

// Hook pattern for monitoring
const hooks = createWorkerHooks(agentType);
```

## 📂 Project Structure Deep Dive

```
src/
├── agents/                    # Multi-agent system core
│   ├── supervisorAgent.ts     # Main coordination logic (1000+ lines)
│   ├── aiVoltAgent.ts        # Monolithic standalone agent with full capabilities
│   ├── supervisorRetriever.ts # RAG for delegation context
│   ├── subAgents.ts          # New modular worker system
│   └── index.ts              # Agent registry & exports
├── tools/                     # Specialized capabilities (47+ tools)
│   ├── calculator.ts         # Math operations, statistics
│   ├── datetime.ts          # Temporal intelligence
│   ├── enhancedGitTool.js   # Git operations, GitHub API
│   ├── codingTools.js       # File ops, code execution
│   ├── webBrowser.js        # Web automation, scraping
│   ├── enhancedWebBrowser.js # Advanced web processing
│   ├── knowledgeBaseTools.js # Document management
│   ├── dataTools.js         # CSV/data processing
│   ├── cloudTools.js        # Docker, container management
│   └── index.ts             # Tool registry
├── config/                   # Environment & logging
│   ├── environment.ts       # Env var validation (Zod)
│   └── logger.ts           # Structured logging
├── prompts/                  # Agent instruction templates
│   └── index.ts             # Prompt management
└── index.ts                  # Application entry point
```

## 🎯 Key Implementation Patterns

### **Agent Creation Pattern**
```typescript
const agent = new Agent({
  name: "SpecializedAgent",
  instructions: workerPrompts.generate("agentType")(),
  llm: new VercelAIProvider(),
  model: google('gemini-2.0-flash'),
  tools: [...specializedTools],
  memory: createWorkerMemory(agentType),
  hooks: createWorkerHooks(agentType),
});
```

### **Delegation Pattern**
```typescript
// Supervisor delegates to workers via `delegate_task` tool
const result = await delegateTask({
  task: "Complex multi-step operation",
  agentType: "git", // Routes to GitAgent
  context: retrievalContext
});
```

### **Memory Isolation**
Each agent maintains isolated memory:
- Supervisor: `.voltagent/supervisor-memory.db`
- Workers: `.voltagent/{agentType}-memory.db`
- AI-Volt: `.voltagent/ai-volt-memory.db`

### **Context Retrieval**
```typescript
// Semantic search for delegation history
const context = await supervisorRetriever.search(
  "similar task patterns",
  { agentType: "git", minScore: 0.8 }
);
```

## 🔒 Security & Validation

### **Input Validation**
All data structures use **Zod schemas**:
```typescript
const TaskSchema = z.object({
  description: z.string().min(1),
  agentType: z.enum(['calculator', 'git', 'coding', ...]),
  priority: z.enum(['high', 'medium', 'low']).default('medium')
});
```

### **Error Handling**
Comprehensive async/await with try-catch:
```typescript
try {
  const result = await agent.process(input);
  logger.info("Task completed", { agentType, duration });
} catch (error) {
  logger.error("Task failed", { error: error.message, agentType });
  throw new TaskExecutionError(error.message);
}
```

## 📊 Monitoring & Observability

### **Structured Logging**
```typescript
logger.info(`[${agent.name}] Task delegation initiated`, {
  sessionId, delegationId, workflowId,
  operationId: context.operationId,
  delegationSequence: newCount,
  timestamp: new Date().toISOString()
});
```

### **Telemetry Integration**
- **OpenTelemetry**: Distributed tracing across agents
- **VoltAgent Exporter**: Performance metrics to VoltAgent cloud
- **Hook-based Monitoring**: Lifecycle events tracked per agent

## 🚀 Development Workflow

### **Adding New Workers**
1. Create agent in `subAgents.ts` or `supervisorAgent.ts`
2. Define specialized tools in `/tools/`
3. Add to worker registry in `createWorkerAgents()`
4. Register in VoltAgent configuration (`index.ts`)

### **Tool Development**
Follow the established pattern:
```typescript
export const newTool = createTool({
  name: 'descriptive_name',
  description: 'Clear tool purpose',
  parameters: ZodSchema,
  execute: async ({ param1, param2 }, { agent }) => {
    // Implementation with error handling
    return { result: processedData };
  }
});
```

### **Testing Multi-Agent Flows**
- Use delegation monitoring via hooks
- Check memory isolation between agents  
- Validate context retrieval accuracy
- Monitor telemetry for performance bottlenecks

## ⚡ Optimization Focus Areas

### **Performance**
- Memory limits per agent (supervisor: 500, workers: 200)
- LRU caching for retrieval operations
- Thinking budget optimization (supervisor: 512, workers: 0)

### **Reliability**
- Graceful degradation if workers fail
- Retry mechanisms for delegation
- Context cleanup for long-running sessions

### **Scalability**
- Modular worker addition
- Horizontal scaling via VoltAgent cloud
- Resource isolation per agent type

## 🎯 **Few-Shot Learning Examples**

GitHub Copilot works best with concrete examples. Here are proven patterns:

### **Task Delegation Examples**
```typescript
// Example 1: Git repository analysis
// Input: "Analyze the commit history and find security issues"
// Expected delegation:
await delegateTask({
  task: "Analyze commit history for security vulnerabilities and code quality issues",
  agentType: "git",
  context: { repository: "current", depth: "last-50-commits" }
});

// Example 2: Multi-step data processing
// Input: "Process CSV file and generate visualization"
// Expected workflow:
1. FileOps Agent → Read and validate CSV
2. Data Agent → Clean and analyze data  
3. Coding Agent → Generate visualization script
4. Browser Agent → Create web-based dashboard
```

### **Worker Agent Specialization Examples**
```typescript
// Calculator Agent - Statistical analysis
// Input: "Calculate correlation between two datasets"
// Output: Statistical report with correlation coefficient, p-value, and visualization

// Git Agent - Repository operations  
// Input: "Create feature branch, commit changes, and open PR"
// Output: Branch created, files committed, pull request opened with description

// Browser Agent - Web automation
// Input: "Extract pricing data from competitor websites"
// Output: Structured data with prices, timestamps, and source URLs

// Coding Agent - Code analysis
// Input: "Find security vulnerabilities in TypeScript codebase"
// Output: Security report with vulnerability details, severity, and fix suggestions
```

## 🔧 **Advanced Tool Ecosystem** 

### **Available Tool Categories (47+ Tools)**
```typescript
// Mathematical & Statistical
calculatorTool, statisticsAnalysisTool

// Temporal Intelligence  
dateTimeTool // Advanced timezone, scheduling, duration calculations

// System & Performance
systemInfoTool // CPU, memory, disk, network monitoring

// File System Operations
readFileTool, writeFileTool, deleteFileTool, listDirectoryTool,
createDirectoryTool, statTool, moveTool, copyTool, replaceLineInFileTool

// Version Control & GitHub
enhancedGitStatusTool, secureGitScriptTool, gitRepositoryAnalysisTool,
gitCloneTool, gitAddTool, gitCommitTool, gitPushTool, gitPullTool,
getFileContentTool, listRepositoryContentsTool, createPullRequestTool

// Web Automation & Scraping  
webSearchTool, extractTextTool, extractLinksTool, extractMetadataTool,
secureWebProcessorTool, webScrapingManagerTool, webContentValidatorTool

// Code Execution & Analysis
sandboxedCodeExecutorTool, lintCodeTool, analyzeCodeComplexityTool,
findCodeDuplicatesTool, identifySecurityAntiPatternsTool

// Browser Automation (Playwright)
navigationTool, screenshotTool, interactionTools, responseTools,
outputTools, visiblePageTools

// Knowledge Management
ingestDocumentTool, queryKnowledgeBaseTool, summarizeDocumentTool,
listKnowledgeBaseDocumentsTool

// Data Processing & Analysis
readDataFromFileTool, analyzeCsvDataTool, writeDataToFileTool

// Cloud & Container Management
deployServiceTool, listContainersTool, stopContainerTool,
removeContainerTool, getContainerLogsTool, inspectContainerTool,
listImagesTool, buildImageTool
```

## 🚀 **Common Multi-Agent Workflows**

### **Example 1: Full-Stack Development Workflow**
```typescript
// Goal: Build and deploy a web application feature
// Workflow sequence:
1. Git Agent → Create feature branch, pull latest changes
2. Coding Agent → Generate component code, run tests  
3. Browser Agent → Test UI functionality, capture screenshots
4. Git Agent → Commit changes, create pull request
5. Cloud Agent → Deploy to staging environment
6. System Agent → Monitor deployment health

// Copilot prompt pattern:
"Create a new React component for user authentication with form validation, 
then test it in the browser and deploy to staging"
```

### **Example 2: Data Analysis & Reporting**
```typescript
// Goal: Analyze business data and create executive report
// Workflow sequence:  
1. File Ops Agent → Read CSV/Excel files from multiple sources
2. Data Agent → Clean, merge, and analyze datasets
3. Calculator Agent → Perform statistical analysis, trend detection
4. Coding Agent → Generate visualization scripts (charts, graphs)
5. Knowledge Base Agent → Create formatted report with insights
6. Browser Agent → Generate web-based interactive dashboard

// Copilot prompt pattern:
"Analyze quarterly sales data from multiple CSV files, identify trends, 
and create an executive dashboard with key metrics and recommendations"
```

### **Example 3: Security Audit Workflow**
```typescript
// Goal: Comprehensive security analysis of codebase
// Workflow sequence:
1. Git Agent → Analyze commit history for sensitive data exposure
2. Coding Agent → Scan code for security vulnerabilities, anti-patterns
3. File Ops Agent → Check file permissions, configuration security  
4. Browser Agent → Test web application for security issues
5. System Agent → Monitor resource usage during security tests
6. Knowledge Base Agent → Generate security report with recommendations

// Copilot prompt pattern:
"Perform a comprehensive security audit of the TypeScript application, 
including code analysis, dependency scanning, and web security testing"
```

## 📚 **Context Optimization Techniques**

### **High-Level Goal Setting (Latest Research)**
```typescript
// ❌ Vague prompt (poor results):
"Fix the code"

// ✅ Context-rich prompt (excellent results):
/**
 * Goal: Implement secure user authentication for AI-Volt multi-agent system
 * Context: TypeScript application using Voltagent framework with Google AI
 * Requirements: JWT tokens, role-based access, session management
 * Integration: Must work with existing LibSQL database and agent memory system
 * Security: Follow OWASP guidelines, implement rate limiting, input validation
 */
```

### **Progressive Refinement Pattern** 
```typescript
// Step 1: High-level architecture
"Design authentication system architecture for multi-agent platform"

// Step 2: Specific implementation  
"Implement JWT middleware for Voltagent agents with role-based permissions"

// Step 3: Integration details
"Integrate authentication with existing LibSQL memory storage and agent hooks"

// Step 4: Testing & validation
"Create comprehensive tests for authentication system including edge cases"
```

## 🔍 **Debugging & Troubleshooting Patterns**

### **Agent Communication Issues**
```typescript
// Common Issue: Agent delegation failures
// Diagnostic approach:
1. Check delegation context and agent availability
2. Verify memory isolation and context keys
3. Examine hook execution and error propagation  
4. Validate tool parameter schemas with Zod

// Copilot debugging prompt:
"Debug agent delegation failure where GitAgent isn't receiving task context. 
Check context key validation, memory isolation, and hook execution flow."
```

### **Memory & Performance Issues**
```typescript
// Common Issue: Memory leaks in long-running agent sessions
// Diagnostic approach:
1. Monitor memory usage per agent type
2. Check retrieval cache size and cleanup
3. Validate LibSQL connection pooling
4. Analyze hook overhead and context accumulation

// Copilot debugging prompt:  
"Investigate memory leak in SupervisorAgent during long delegation sessions. 
Check retrieval cache cleanup, context accumulation, and LibSQL storage limits."
```

## 🎨 **Advanced Prompt Engineering Techniques**

### **Example-Driven Development**
```typescript
// Technique: Show desired outcome first
// Example: Data transformation task
// Desired outcome: Convert agent metrics to dashboard format
const input = [
  { agentType: 'git', taskCount: 15, avgDuration: 2500 },
  { agentType: 'coding', taskCount: 8, avgDuration: 4200 }
];

const expectedOutput = {
  dashboard: {
    totalTasks: 23,
    agentEfficiency: { git: 'high', coding: 'medium' },
    recommendations: ['Optimize coding agent tools', 'Increase git agent capacity']
  }
};

// Implementation follows with this context
```

### **Domain-Specific Patterns**
```typescript
// For Voltagent Framework:
// Always mention: Agent creation, tool registration, memory management, hooks
"Create a new worker agent for PDF processing using Voltagent patterns,
with isolated LibSQL memory, comprehensive hooks, and specialized PDF tools"

// For Multi-Agent Systems:  
// Always mention: Delegation, coordination, context sharing, error propagation
"Implement cross-agent workflow for document processing with proper delegation,
context passing between agents, and coordinated error handling"

// For TypeScript + AI:
// Always mention: Type safety, Zod validation, async/await, error boundaries
"Build type-safe agent communication layer with Zod schemas, proper async handling,
and comprehensive error boundaries for multi-agent coordination"
```

## 🚀 **Performance Optimization Examples**

### **Memory Management Patterns**
```typescript
// Example: Efficient memory usage across agents
const optimizedMemoryConfig = {
  supervisor: { limit: 500, cleanup: '1h' },    // High coordination needs
  workers: { limit: 200, cleanup: '30m' },      // Focused task execution  
  retrieval: { cache: 200, ttl: '15m' },        // Semantic search cache
  global: { maxAgents: 12, poolSize: 4 }        // Resource constraints
};

// Copilot optimization prompt:
"Optimize memory usage for 12-agent system with frequent delegations,
implementing efficient cleanup cycles and cache management strategies"
```

### **Tool Chain Optimization**
```typescript
// Example: Optimal tool selection for complex workflows
const workflowOptimization = {
  // Prefer composite tools for related operations
  gitWorkflow: ['enhancedGitStatusTool', 'gitRepositoryAnalysisTool'], 
  // Use specialized tools for performance-critical paths
  dataProcessing: ['analyzeCsvDataTool', 'statisticsAnalysisTool'],
  // Batch operations for efficiency  
  fileOperations: ['batchFileProcessorTool', 'directoryAnalysisTool']
};
```

## 💡 **Latest GitHub Copilot Features**

### **Context-Aware Suggestions**
- **File Context**: Copilot reads all open files for better context
- **Git History**: Recent commits inform code suggestions
- **Project Structure**: Understanding of multi-file relationships
- **Framework Patterns**: Recognition of Voltagent/Vercel AI SDK patterns

### **Advanced Prompt Techniques**
```typescript
// Multi-line comment prompts for complex tasks
/*
Task: Implement secure agent-to-agent communication
Context: AI-Volt multi-agent system with 12 specialized workers
Framework: Voltagent + Vercel AI SDK + Google AI (Gemini)
Security: End-to-end encryption, authentication, audit logging
Performance: Sub-100ms delegation latency, memory efficient
Integration: Existing LibSQL storage, OpenTelemetry tracing
*/

// Inline examples with expected outcomes
// Example input: { task: "analyze code", agentType: "coding" }
// Expected: Delegate to CodingAgent, return analysis report with metrics
// Implementation:
```

This enhanced guidance incorporates the latest research on GitHub Copilot effectiveness, ensuring maximum code generation quality and accuracy for your sophisticated multi-agent system.
