---
description: 'A set of core principles to guide the behavior of all AI agents in the AI-Volt project.'
applyTo: "**/*.ts"
title: 'Guiding Philosophy for AI Agents'
name: 'philosophy'
tags: ['refactor', 'tooling']

---

# ðŸ¤– AI-Volt TypeScript Development Instructions
## Advanced Multi-Agent System with Voltagent Framework

### ðŸ—ï¸ **CRITICAL WORKFLOW MANDATE**
After EVERY file modification or code generation, you MUST leverage error checking for thorough validation. Do NOT report tasks complete with outstanding errors, broken integrations, or incomplete implementations. Ensure full integration and functionality verification.

### ðŸ“‹ **PROJECT CONTEXT & ARCHITECTURE**

This is **AI-Volt** - a sophisticated multi-agent orchestration platform built with:
- **Framework**: [Voltagent](https://voltagent.dev/docs/) (`@voltagent/core`, `@voltagent/vercel-ai`)
- **AI Provider**: [Vercel AI-SDK Google](https://ai-sdk.dev/providers/ai-sdk-providers/google-generative-ai) (Gemini 2.5 Flash)
- **Architecture**: Supervisor/Worker pattern with 12+ specialized agents
- **Database**: LibSQL/Turso for persistent memory per agent
- **Monitoring**: OpenTelemetry + Langfuse integration
- **Language**: TypeScript with strict type safety

### ðŸŽ¯ **CORE DEVELOPMENT PRINCIPLES**

#### **1. Multi-Agent System Patterns**
```typescript
// Agent creation follows strict pattern
const agent = new Agent({
  name: "SpecializedWorker",
  instructions: workerPrompts.generate("agentType")(),
  llm: new VercelAIProvider(),
  model: google('gemini-2.0-flash'),
  tools: [...specializedTools],
  memory: createWorkerMemory(agentType),
  hooks: createWorkerHooks(agentType),
});

// Memory isolation per agent
const memory = new LibSQLStorage({
  url: `file:./.voltagent/${agentType}-memory.db`,
  tablePrefix: `${agentType}_memory`,
  storageLimit: 200, // Workers: 200, Supervisor: 500
  debug: env.NODE_ENV === "development"
});
```

#### **2. Delegation & Coordination**
```typescript
// Supervisor delegates via delegate_task tool
await agent.delegate(taskDescription, {
  agentType: 'calculator|datetime|git|coding|browser|...',
  priority: 'high|medium|low',
  context: retrievalContext
});

// Context tracking for delegation
context.userContext.set(CONTEXT_KEYS.DELEGATION_ID, delegationId);
context.userContext.set(CONTEXT_KEYS.WORKFLOW_ID, workflowId);
```

#### **3. Identifier Generation Standard**
```typescript
// ALWAYS use AI SDK's generateId for unique IDs
import { generateId } from 'ai';

const sessionId = `session-${generateId()}`;
const delegationId = `delegation-${generateId()}`;
const taskId = `${agentType}-task-${generateId()}`;
```

### ðŸ”’ **TYPE SAFETY & VALIDATION**

#### **Zod Schema Patterns**
```typescript
// ALL data structures MUST use Zod validation
import { z } from 'zod';

const TaskSchema = z.object({
  description: z.string().min(1),
  agentType: z.enum(['calculator', 'datetime', 'git', 'coding', 'browser', 'research']),
  priority: z.enum(['high', 'medium', 'low']).default('medium'),
  context: z.record(z.unknown()).optional()
});

// Validate at boundaries
const validatedTask = TaskSchema.parse(inputTask);
```

#### **Error Handling Pattern**
```typescript
// ALL async operations MUST be wrapped
try {
  const result = await agent.process(validatedInput);
  logger.info("Task completed successfully", { 
    agentType, 
    duration: Date.now() - startTime,
    operationId: context.operationId 
  });
  return result;
} catch (error) {
  logger.error("Task execution failed", {
    agentType,
    error: error instanceof Error ? error.message : String(error),
    operationId: context.operationId
  });
  throw new TaskExecutionError(`${agentType} failed: ${error.message}`);
}
```

### ðŸ› ï¸ **TOOL DEVELOPMENT FRAMEWORK**

#### **Standard Tool Pattern**
```typescript
export const newSpecializedTool = createTool({
  name: 'descriptive_tool_name',
  description: 'Clear, specific tool purpose and capabilities',
  parameters: z.object({
    input: z.string().describe('Input parameter description'),
    options: z.object({
      format: z.enum(['json', 'text']).default('json')
    }).optional()
  }),
  execute: async ({ input, options }, { agent }) => {
    try {
      // Tool implementation with validation
      const processed = await processInput(input, options);
      
      // ALWAYS return string for tool output
      return typeof processed === 'string' 
        ? processed 
        : JSON.stringify(processed);
    } catch (error) {
      logger.error(`Tool ${tool.name} failed`, { 
        error: error.message,
        input: input.substring(0, 100) 
      });
      throw error;
    }
  }
});
```

#### **Tool Categories & Organization**
- **Calculator Tools**: `calculator.ts`, `statisticsAnalysisTool`
- **DateTime Tools**: `datetime.ts` - temporal operations
- **Git Tools**: `enhancedGitTool.js` - version control, GitHub API
- **Coding Tools**: `codingTools.js` - file ops, code execution, linting
- **Web Tools**: `webBrowser.js`, `enhancedWebBrowser.js` - scraping, automation
- **Data Tools**: `dataTools.js` - CSV processing, analysis
- **Cloud Tools**: `cloudTools.js` - Docker, deployment
- **Knowledge Tools**: `knowledgeBaseTools.js` - document management

### ðŸ“Š **MONITORING & OBSERVABILITY**

#### **Structured Logging Pattern**
```typescript
// Use project logger, NOT console.log
import { logger } from '../config/logger.js';

// Agent lifecycle logging
logger.info(`[${agent.name}] Task delegation initiated`, {
  sessionId: context.userContext.get(CONTEXT_KEYS.SESSION_ID),
  delegationId: context.userContext.get(CONTEXT_KEYS.DELEGATION_ID),
  workflowId: context.userContext.get(CONTEXT_KEYS.WORKFLOW_ID),
  operationId: context.operationId,
  agentType,
  timestamp: new Date().toISOString()
});

// Error logging with context
logger.error(`[${agent.name}] Operation failed`, {
  error: error instanceof Error ? error.message : String(error),
  stack: error instanceof Error ? error.stack : undefined,
  context: { agentType, taskId, sessionId }
});
```

#### **Hook-Based Monitoring**
```typescript
// ALL agents must implement comprehensive hooks
const hooks = createWorkerHooks(agentType);

const createWorkerHooks = (agentType: string) => createHooks({
  onStart: async ({ agent, context }) => {
    const taskId = `${agentType}-task-${generateId()}`;
    context.userContext.set(WORKER_CONTEXT_KEYS.TASK_ID, taskId);
    context.userContext.set(WORKER_CONTEXT_KEYS.START_TIME, Date.now());
    
    logger.info(`[${agent.name}] Worker task started`, {
      taskId, agentType, operationId: context.operationId
    });
  },
  onEnd: async ({ agent, output, error, context }) => {
    const duration = Date.now() - context.userContext.get(WORKER_CONTEXT_KEYS.START_TIME);
    // Comprehensive completion logging
  },
  onToolStart: async ({ tool, context }) => {
    context.userContext.set(`toolStart-${tool.name}`, Date.now());
  },
  onToolEnd: async ({ tool, output, error, context }) => {
    const toolDuration = Date.now() - context.userContext.get(`toolStart-${tool.name}`);
    // Tool execution monitoring
  }
});
```

### ðŸ”„ **MEMORY & CONTEXT MANAGEMENT**

#### **Memory Isolation Strategy**
```typescript
// Each agent type gets isolated memory
const createWorkerMemory = (agentType: string) => {
  return new LibSQLStorage({
    url: `file:./.voltagent/${agentType}-memory.db`,
    tablePrefix: `${agentType}_memory`,
    storageLimit: agentType === 'supervisor' ? 500 : 200,
    debug: env.NODE_ENV === "development"
  });
};
```

#### **Context Retrieval Pattern**
```typescript
// Supervisor retrieval for delegation context
const retriever = createSupervisorRetriever({
  maxResults: 15,
  storeMaxSize: 1000,
  searchCacheSize: 200
});

// Add delegation context for future retrieval
retriever.addDelegationContext({
  agentType,
  task: taskDescription,
  result: result.substring(0, 500),
  taskId: delegationId,
  workflowId,
  success: !error,
  duration: Date.now() - startTime
});
```

### ðŸŒ **ENVIRONMENT & CONFIGURATION**

#### **Environment Variables Pattern**
```typescript
// ALL configs via environment variables
import { env } from '../config/environment.js';

// Never hardcode sensitive values
const apiKey = env.GOOGLE_AI_API_KEY;
const databaseUrl = env.DATABASE_URL || "file:./.voltagent/default.db";

// Validate environment on startup
const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  GOOGLE_AI_API_KEY: z.string().min(1),
  PORT: z.coerce.number().default(3000),
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info')
});
```

### âš¡ **PERFORMANCE OPTIMIZATION**

#### **Memory Limits & Caching**
```typescript
// Supervisor configuration
const SUPERVISOR_CONFIG = {
  MEMORY: {
    STORAGE_LIMIT: 500,
    WORKER_STORAGE_LIMIT: 200,
  },
  RETRIEVER: {
    MAX_RESULTS: 15,
    STORE_MAX_SIZE: 1000,
    SEARCH_CACHE_SIZE: 200,
  },
  MODELS: {
    THINKING_BUDGET: 512,      // Supervisor gets thinking budget
    WORKER_THINKING_BUDGET: 0, // Workers run without thinking
  }
};
```

#### **React State Management (if UI components)**
```typescript
// ALWAYS use immutable updates
const [state, setState] = useState(initialState);

// Correct immutable update
setState(prevState => ({
  ...prevState,
  agents: {
    ...prevState.agents,
    [agentId]: { ...prevState.agents[agentId], status: 'active' }
  }
}));
```

### ðŸ“š **DOCUMENTATION STANDARDS**

#### **TSDoc for ALL Exports**
```typescript
/**
 * Creates a specialized worker agent for specific domain tasks.
 * 
 * @param agentType - The type of specialized worker to create
 * @param tools - Array of tools specific to this worker's domain
 * @param memory - Optional memory storage, defaults to agent-specific storage
 * @returns Configured worker agent ready for delegation
 * 
 * @example
 * ```typescript
 * const gitWorker = createWorkerAgent('git', [gitTools], gitMemory);
 * ```
 * 
 * @throws {AgentCreationError} When required tools are missing
 */
export const createWorkerAgent = (
  agentType: string,
  tools: Tool[],
  memory?: LibSQLStorage
): Agent => {
  // Implementation
};
```

### ðŸš« **ANTI-PATTERNS TO AVOID**

#### **Memory & Context**
- âŒ Sharing memory storage between agents
- âŒ Using global variables for agent state
- âŒ Hardcoding agent capabilities or tool lists

#### **Error Handling**
- âŒ Using `any` type instead of proper error types
- âŒ Swallowing errors without logging
- âŒ Not validating inputs with Zod schemas

#### **Performance**
- âŒ Creating new agents in hot paths
- âŒ Not setting thinking budgets appropriately
- âŒ Ignoring memory limits and cache sizes

#### **Tools & Delegation**
- âŒ Tools returning non-string outputs
- âŒ Direct agent-to-agent communication (use delegation)
- âŒ Not using the established tool development pattern

### ðŸ”„ **DEPENDENCY MANAGEMENT**

**Package Manager**: ALWAYS use `npm` (never yarn or pnpm)
```bash
# Adding dependencies
npm install @new/package
npm install -D @dev/package

# Project uses these core dependencies:
# - @voltagent/core @voltagent/vercel-ai
# - @ai-sdk/google
# - zod (validation)
# - quick-lru (caching)
# - @xenova/transformers (embeddings)
```

### ðŸŽ¯ **CODE GENERATION GUIDELINES**

#### **Generated Code Comments**
```typescript
// Generated on 2025-01-15 - Multi-agent calculator worker
export const createCalculatorAgent = (): Agent => {
  // TODO: 2025-01-15 - Add statistics analysis capabilities
  return new Agent({
    // Implementation
  });
};
```

#### **Integration Checklist**
- âœ… Agent properly registered in VoltAgent configuration
- âœ… Memory storage isolated and configured  
- âœ… Hooks implemented for monitoring
- âœ… Tools follow established patterns
- âœ… Error handling with try-catch blocks
- âœ… Zod validation for all inputs
- âœ… TSDoc documentation for exports
- âœ… Logging with structured context

This TypeScript configuration ensures AI-Volt maintains its sophisticated multi-agent architecture while following cutting-edge development practices for reliability, performance, and maintainability.